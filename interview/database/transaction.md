# 事务

## 事务的四个特性
[参考链接](https://www.cnblogs.com/huanongying/p/7021555.html)

ACID

-   原子性（Atomicity）

    事务要么全做，要么不做

-   一致性（Consistency）

    事务前后要保证不破坏完整性约束

-   隔离性

    同一时期最多一个事务请求同一数据

-   持久性

    事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

## 事务的并发问题

-   脏读

    事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

-   不可重复读

    事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。

-   幻读
    
    系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

>   小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表


## 事务的四个隔离级别

### 隔离级别

|事务隔离级别|	脏读	|不可重复读|	幻读|
|----------|--------|------|--------|
|读未提交（read-uncommitted）|	是	|是	|是|
|不可重复读（read-committed）|	否|	是	|是|
|可重复读（repeatable-read）	|否|	否	|是|
|串行化（serializable）|	否	|否|	否|

mysql默认级别是可重复读(repeatable-read)

### [隔离级别实现方式](https://www.cnblogs.com/heyboom/p/9167394.html)


#### 读未提交

-   读数据不加锁
-   写数据加共享锁

#### 不可重复读

-   读数据加行级共享锁，读完释放
-   写数据加行级排他锁

#### 可重复读

-   读数据时对数据加行共享锁，事务结束释放
-   写数据时对数据加行排他锁，事务结束释放

### 可串行化

-   读数据对表加共享锁，直到事务结束
-   写数据时对表加排他锁，直到事务结束





